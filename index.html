<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Football Card Strategy Game - Phaser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #1e3c72;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            width: 100%;
            height: 100%;
            max-width: 420px;
            max-height: 700px;
            position: relative;
        }

        @media (min-width: 768px) {
            #game-container {
                width: 400px;
                height: 700px;
                border-radius: 20px;
                overflow: hidden;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
</head>
<body>
    <div id="game-container"></div>

    <script>
        class FootballCardGame extends Phaser.Scene {
            constructor() {
                super({ key: 'FootballCardGame' });
                
                // Game state
                this.selectedCards = new Set();
                this.playerYards = 10;
                this.enemyYards = 0;
                this.round = 1;
                this.hasDiscardedThisRound = false;
                
                // Deck data
                this.playerDeck = [
                    { name: 'MAHOMES', cost: 8, rarity: 6, position: 'QB' },
                    { name: 'ALLEN', cost: 7, rarity: 6, position: 'QB' },
                    { name: 'BURROW', cost: 6, rarity: 5, position: 'QB' },
                    { name: 'HURTS', cost: 5, rarity: 4, position: 'QB' },
                    { name: 'LAMAR', cost: 6, rarity: 5, position: 'QB' },
                    { name: 'HENRY', cost: 7, rarity: 5, position: 'RB' },
                    { name: 'MCCAFFREY', cost: 8, rarity: 6, position: 'RB' },
                    { name: 'CHUBB', cost: 5, rarity: 4, position: 'RB' },
                    { name: 'COOK', cost: 4, rarity: 3, position: 'RB' },
                    { name: 'KUPP', cost: 6, rarity: 5, position: 'WR' },
                    { name: 'JEFFERSON', cost: 7, rarity: 6, position: 'WR' },
                    { name: 'DIGGS', cost: 5, rarity: 4, position: 'WR' },
                    { name: 'ADAMS', cost: 6, rarity: 5, position: 'WR' },
                    { name: 'KELCE', cost: 7, rarity: 6, position: 'TE' },
                    { name: 'WATT', cost: 8, rarity: 6, position: 'DE' }
                ];
                
                this.enemyDeck = [
                    { name: 'RODGERS', cost: 7, rarity: 5, position: 'QB' },
                    { name: 'WILSON', cost: 6, rarity: 4, position: 'QB' },
                    { name: 'PRESCOTT', cost: 5, rarity: 4, position: 'QB' },
                    { name: 'STAFFORD', cost: 5, rarity: 3, position: 'QB' },
                    { name: 'JONES', cost: 4, rarity: 3, position: 'QB' },
                    { name: 'BARKLEY', cost: 7, rarity: 5, position: 'RB' },
                    { name: 'JONES II', cost: 6, rarity: 4, position: 'RB' },
                    { name: 'MIXON', cost: 5, rarity: 4, position: 'RB' },
                    { name: 'HARRIS', cost: 4, rarity: 3, position: 'RB' },
                    { name: 'HILL', cost: 7, rarity: 6, position: 'WR' },
                    { name: 'CHASE', cost: 6, rarity: 5, position: 'WR' },
                    { name: 'HOPKINS', cost: 5, rarity: 4, position: 'WR' },
                    { name: 'EVANS', cost: 5, rarity: 4, position: 'WR' },
                    { name: 'KITTLE', cost: 6, rarity: 5, position: 'TE' },
                    { name: 'DONALD', cost: 8, rarity: 6, position: 'DT' }
                ];
                
                // Initialize arrays
                this.playerHand = [];
                this.playerDrawPile = [];
                this.playerDiscardPile = [];
                this.enemyHand = [];
                this.enemyDrawPile = [];
                this.enemyDiscardPile = [];
                this.fieldCards = { player: [], enemy: [] };
                
                // UI elements
                this.handCardSprites = [];
                this.fieldCardSprites = { player: [], enemy: [] };
            }

            create() {
                console.log('Game scene created');
                const { width, height } = this.scale;
                
                // Background
                this.add.rectangle(0, 0, width, height, 0xf8f9fa).setOrigin(0, 0);
                
                // Field section (top 40%)
                this.fieldHeight = height * 0.4;
                const field = this.add.rectangle(0, 0, width, this.fieldHeight, 0x4CAF50).setOrigin(0, 0);
                
                // Field lines
                for (let i = 0; i < 10; i++) {
                    const y = (this.fieldHeight / 10) * i;
                    this.add.rectangle(0, y, width, 2, 0xffffff, 0.3).setOrigin(0, 0);
                }
                
                // Field zones
                this.enemyZoneY = 80;
                this.playerZoneY = this.fieldHeight - 80;
                
                // Hand section (bottom 60%)
                const handBg = this.add.rectangle(0, this.fieldHeight, width, height - this.fieldHeight, 0x2c3e50).setOrigin(0, 0);
                
                // UI Text
                this.enemyYardsText = this.add.text(width / 2, 20, 'Enemy Yards 0/100', {
                    fontSize: '14px',
                    color: '#333',
                    backgroundColor: '#ffffffee',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5, 0.5);
                
                this.playerYardsText = this.add.text(width / 2, this.fieldHeight - 20, 'Your Yards 10/100', {
                    fontSize: '14px',
                    color: '#333',
                    backgroundColor: '#ffffffee',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5, 0.5);
                
                this.enemyDeckText = this.add.text(width - 10, 10, 'Enemy: 15/15', {
                    fontSize: '12px',
                    color: '#fff',
                    backgroundColor: '#ff0000cc',
                    padding: { x: 6, y: 4 }
                }).setOrigin(1, 0);
                
                // Buttons
                this.createButtons();
                
                // Cards remaining text
                this.cardsRemainingText = this.add.text(width / 2, this.fieldHeight + 30, 'Available 15/15', {
                    fontSize: '14px',
                    color: '#fff',
                    backgroundColor: '#ffffff22',
                    padding: { x: 10, y: 6 }
                }).setOrigin(0.5, 0.5);
                
                // Initialize game
                this.initializeGame();
            }

            createButtons() {
                const { width, height } = this.scale;
                const buttonY = this.fieldHeight + 30;
                
                // Discard button
                this.discardBtn = this.add.container(80, buttonY);
                const discardBg = this.add.rectangle(0, 0, 100, 40, 0xe74c3c);
                discardBg.setInteractive({ useHandCursor: true });
                const discardText = this.add.text(0, 0, 'SUB OUT', {
                    fontSize: '12px',
                    color: '#fff',
                    fontStyle: 'bold'
                }).setOrigin(0.5, 0.5);
                this.discardBtn.add([discardBg, discardText]);
                
                discardBg.on('pointerdown', () => this.discardSelected());
                discardBg.on('pointerover', () => discardBg.setScale(1.1));
                discardBg.on('pointerout', () => discardBg.setScale(1));
                
                // Play button
                this.playBtn = this.add.container(width - 80, buttonY);
                const playBg = this.add.rectangle(0, 0, 100, 40, 0x27ae60);
                playBg.setInteractive({ useHandCursor: true });
                const playText = this.add.text(0, 0, 'SNAP ðŸˆ', {
                    fontSize: '12px',
                    color: '#fff',
                    fontStyle: 'bold'
                }).setOrigin(0.5, 0.5);
                this.playBtn.add([playBg, playText]);
                
                playBg.on('pointerdown', () => this.playSelectedCards());
                playBg.on('pointerover', () => playBg.setScale(1.1));
                playBg.on('pointerout', () => playBg.setScale(1));
            }

            initializeGame() {
                // Shuffle and initialize decks
                this.playerDrawPile = Phaser.Utils.Array.Shuffle([...this.playerDeck]).map((card, i) => ({
                    ...card,
                    id: `deck-${i}`
                }));
                
                this.enemyDrawPile = Phaser.Utils.Array.Shuffle([...this.enemyDeck]).map((card, i) => ({
                    ...card,
                    id: `enemy-deck-${i}`
                }));
                
                // Start first round
                this.startNewRound();
            }

            startNewRound() {
                // Draw cards
                this.drawPlayerCards(6);
                this.drawEnemyCards(6);
                
                // Enemy plays cards
                const enemyPower = this.playEnemyCards();
                
                // Render everything
                this.renderHand();
                this.renderFieldCards();
                this.updateUI();
                
                // Show message
                this.showMessage(`Round ${this.round} starts! Enemy: ${enemyPower} power`);
            }

            drawPlayerCards(count) {
                for (let i = 0; i < count; i++) {
                    if (this.playerDrawPile.length === 0 && this.playerDiscardPile.length > 0) {
                        this.shuffleDiscardIntoDeck();
                    }
                    
                    const card = this.playerDrawPile.shift();
                    if (card) {
                        card.id = `hand-${Date.now()}-${Math.random()}`;
                        this.playerHand.push(card);
                    }
                }
            }

            drawEnemyCards(count) {
                for (let i = 0; i < count; i++) {
                    if (this.enemyDrawPile.length === 0 && this.enemyDiscardPile.length > 0) {
                        this.shuffleEnemyDiscardIntoDeck();
                    }
                    
                    const card = this.enemyDrawPile.shift();
                    if (card) {
                        card.id = `enemy-hand-${Date.now()}-${Math.random()}`;
                        this.enemyHand.push(card);
                    }
                }
            }

            playEnemyCards() {
                let totalPower = 0;
                
                this.enemyHand.forEach(card => {
                    totalPower += card.cost + card.rarity;
                    this.fieldCards.enemy.push({
                        ...card,
                        id: `enemy-field-${Date.now()}-${Math.random()}`
                    });
                });
                
                this.enemyHand = [];
                return totalPower;
            }

            renderHand() {
                // Clear existing hand sprites
                this.handCardSprites.forEach(sprite => sprite.destroy());
                this.handCardSprites = [];
                
                const { width } = this.scale;
                const cardWidth = 80;
                const cardHeight = 110;
                const startY = this.fieldHeight + 140;
                const spacing = 20;
                const cardsPerRow = 3;
                
                this.playerHand.forEach((card, index) => {
                    const row = Math.floor(index / cardsPerRow);
                    const col = index % cardsPerRow;
                    
                    // Calculate cards in this row
                    const cardsInThisRow = Math.min(cardsPerRow, this.playerHand.length - (row * cardsPerRow));
                    
                    // Calculate starting X position to center the row
                    const totalRowWidth = (cardsInThisRow * cardWidth) + ((cardsInThisRow - 1) * spacing);
                    const startX = (width - totalRowWidth) / 2;
                    
                    // Position card
                    const x = startX + col * (cardWidth + spacing) + cardWidth / 2;
                    const y = startY + row * (cardHeight + spacing);
                    
                    const cardSprite = this.createHandCard(card, x, y);
                    this.handCardSprites.push(cardSprite);
                    
                    // Entrance animation
                    cardSprite.setScale(0);
                    this.tweens.add({
                        targets: cardSprite,
                        scaleX: 1,
                        scaleY: 1,
                        duration: 300,
                        delay: index * 50,
                        ease: 'Back.easeOut'
                    });
                });
            }

            createHandCard(cardData, x, y) {
                const container = this.add.container(x, y);
                container.setSize(80, 110);
                container.setInteractive({ useHandCursor: true });
                container.setData('cardId', cardData.id);
                container.setData('cardData', cardData);
                container.setData('originalY', y);
                
                // Card background with gradient effect
                const bg = this.add.graphics();
                bg.fillStyle(0x667eea);
                bg.fillRoundedRect(-40, -55, 80, 110, 8);
                bg.lineStyle(2, 0xffffff);
                bg.strokeRoundedRect(-40, -55, 80, 110, 8);
                
                // Cost circle
                const costBg = this.add.graphics();
                costBg.fillStyle(0xf39c12);
                costBg.fillCircle(-25, -40, 12);
                const costText = this.add.text(-25, -40, cardData.cost.toString(), {
                    fontSize: '12px',
                    color: '#fff',
                    fontStyle: 'bold'
                }).setOrigin(0.5, 0.5);
                
                // Rarity circle
                const rarityBg = this.add.graphics();
                rarityBg.fillStyle(0xe74c3c);
                rarityBg.fillCircle(25, -40, 12);
                const rarityText = this.add.text(25, -40, cardData.rarity.toString(), {
                    fontSize: '12px',
                    color: '#fff',
                    fontStyle: 'bold'
                }).setOrigin(0.5, 0.5);
                
                // Position badge
                const posBg = this.add.graphics();
                posBg.fillStyle(0xffffff, 0.9);
                posBg.fillRoundedRect(10, -22, 25, 15, 4);
                const positionText = this.add.text(22, -15, cardData.position, {
                    fontSize: '10px',
                    color: '#333',
                    fontStyle: 'bold'
                }).setOrigin(0.5, 0.5);
                
                // Card name
                const nameText = this.add.text(0, 20, cardData.name, {
                    fontSize: '11px',
                    color: '#fff',
                    fontStyle: 'bold',
                    wordWrap: { width: 70 },
                    align: 'center'
                }).setOrigin(0.5, 0.5);
                
                container.add([bg, costBg, costText, rarityBg, rarityText, posBg, positionText, nameText]);
                
                // Store background reference for selection highlighting
                container.setData('bg', bg);
                
                // Click handler
                container.on('pointerdown', () => this.toggleCardSelection(container));
                
                // Hover effects
                container.on('pointerover', () => {
                    if (!this.selectedCards.has(cardData.id)) {
                        this.tweens.add({
                            targets: container,
                            y: y - 10,
                            scaleX: 1.05,
                            scaleY: 1.05,
                            duration: 200
                        });
                    }
                });
                
                container.on('pointerout', () => {
                    if (!this.selectedCards.has(cardData.id)) {
                        this.tweens.add({
                            targets: container,
                            y: y,
                            scaleX: 1,
                            scaleY: 1,
                            duration: 200
                        });
                    }
                });
                
                return container;
            }

            toggleCardSelection(cardContainer) {
                const cardId = cardContainer.getData('cardId');
                const bg = cardContainer.getData('bg');
                const originalY = cardContainer.getData('originalY');
                
                if (this.selectedCards.has(cardId)) {
                    this.selectedCards.delete(cardId);
                    bg.clear();
                    bg.fillStyle(0x667eea);
                    bg.fillRoundedRect(-40, -55, 80, 110, 8);
                    bg.lineStyle(2, 0xffffff);
                    bg.strokeRoundedRect(-40, -55, 80, 110, 8);
                    
                    this.tweens.add({
                        targets: cardContainer,
                        y: originalY,
                        scaleX: 1,
                        scaleY: 1,
                        duration: 200
                    });
                } else {
                    this.selectedCards.add(cardId);
                    bg.clear();
                    bg.fillStyle(0x667eea);
                    bg.fillRoundedRect(-40, -55, 80, 110, 8);
                    bg.lineStyle(4, 0xffd700);
                    bg.strokeRoundedRect(-40, -55, 80, 110, 8);
                    
                    this.tweens.add({
                        targets: cardContainer,
                        y: originalY - 15,
                        scaleX: 1.1,
                        scaleY: 1.1,
                        duration: 200
                    });
                }
            }

            renderFieldCards() {
                // Clear existing field sprites
                this.fieldCardSprites.player.forEach(sprite => sprite.destroy());
                this.fieldCardSprites.enemy.forEach(sprite => sprite.destroy());
                this.fieldCardSprites = { player: [], enemy: [] };
                
                const { width } = this.scale;
                const cardWidth = 60;
                const spacing = 2;
                
                // Render enemy cards
                const enemyStartX = (width - (this.fieldCards.enemy.length * (cardWidth + spacing) - spacing)) / 2;
                this.fieldCards.enemy.forEach((card, index) => {
                    const x = enemyStartX + index * (cardWidth + spacing) + cardWidth / 2;
                    const sprite = this.createFieldCard(card, x, this.enemyZoneY, true);
                    this.fieldCardSprites.enemy.push(sprite);
                    
                    // Animation
                    sprite.setScale(0);
                    this.tweens.add({
                        targets: sprite,
                        scaleX: 1,
                        scaleY: 1,
                        duration: 300,
                        delay: index * 100,
                        ease: 'Back.easeOut'
                    });
                });
                
                // Render player cards
                const playerStartX = (width - (this.fieldCards.player.length * (cardWidth + spacing) - spacing)) / 2;
                this.fieldCards.player.forEach((card, index) => {
                    const x = playerStartX + index * (cardWidth + spacing) + cardWidth / 2;
                    const sprite = this.createFieldCard(card, x, this.playerZoneY, false);
                    this.fieldCardSprites.player.push(sprite);
                    
                    // Animation
                    sprite.setScale(0);
                    this.tweens.add({
                        targets: sprite,
                        scaleX: 1,
                        scaleY: 1,
                        duration: 300,
                        delay: index * 100,
                        ease: 'Back.easeOut'
                    });
                });
            }

            createFieldCard(cardData, x, y, isEnemy) {
                const container = this.add.container(x, y);
                
                // Card background
                const bg = this.add.graphics();
                bg.fillStyle(isEnemy ? 0xff6b6b : 0x4ecdc4);
                bg.fillRoundedRect(-30, -40, 55, 73, 6);
                bg.lineStyle(2, 0xffffff);
                bg.strokeRoundedRect(-30, -40, 55, 73, 6);
                
                // Position text
                const posText = this.add.text(0, -20, cardData.position, {
                    fontSize: '10px',
                    color: '#fff',
                    fontStyle: 'bold'
                }).setOrigin(0.5, 0.5);
                
                // Name text
                const nameText = this.add.text(0, 5, cardData.name, {
                    fontSize: '9px',
                    color: '#fff',
                    fontStyle: 'bold',
                    wordWrap: { width: 50 },
                    align: 'center'
                }).setOrigin(0.5, 0.5);
                
                container.add([bg, posText, nameText]);
                
                // Floating animation
                this.tweens.add({
                    targets: container,
                    y: y - 5,
                    duration: 2000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                return container;
            }

            playSelectedCards() {
                if (this.selectedCards.size === 0) {
                    this.showMessage("Select cards to play!");
                    return;
                }
                
                let totalPower = 0;
                const cardsToPlay = [];
                
                // Calculate power and collect cards to play
                this.playerHand.forEach((card, index) => {
                    if (this.selectedCards.has(card.id)) {
                        totalPower += card.cost + card.rarity;
                        cardsToPlay.push({ card, index });
                        
                        // Add to field
                        this.fieldCards.player.push({
                            ...card,
                            id: `field-${Date.now()}-${Math.random()}`
                        });
                    }
                });
                
                // Animate cards leaving hand
                cardsToPlay.forEach(({ index }) => {
                    const sprite = this.handCardSprites[index];
                    if (sprite) {
                        this.tweens.add({
                            targets: sprite,
                            scaleX: 0,
                            scaleY: 0,
                            rotation: Math.PI,
                            duration: 300,
                            onComplete: () => sprite.destroy()
                        });
                    }
                });
                
                // Remove played cards from hand and render field cards immediately
                setTimeout(() => {
                    cardsToPlay.sort((a, b) => b.index - a.index);
                    cardsToPlay.forEach(({ index }) => {
                        this.playerHand.splice(index, 1);
                    });
                    
                    // Render the new field cards
                    this.renderFieldCards();
                    
                    // Discard remaining hand
                    this.discardRemainingHand();
                    
                    // Clear selection
                    this.selectedCards.clear();
                    
                    // End round after a short delay to see the cards on field
                    setTimeout(() => {
                        this.endRound(totalPower);
                    }, 1000);
                }, 400);
            }

            discardSelected() {
                if (this.selectedCards.size === 0) {
                    this.showMessage("Select cards to discard!");
                    return;
                }
                
                if (this.hasDiscardedThisRound) {
                    this.showMessage("Already discarded this round!");
                    return;
                }
                
                const discardCount = this.selectedCards.size;
                const cardsToDiscard = [];
                
                // Collect cards to discard
                this.playerHand.forEach((card, index) => {
                    if (this.selectedCards.has(card.id)) {
                        this.playerDiscardPile.push({
                            name: card.name,
                            cost: card.cost,
                            rarity: card.rarity,
                            position: card.position
                        });
                        cardsToDiscard.push(index);
                    }
                });
                
                // Animate cards being discarded
                cardsToDiscard.forEach((index) => {
                    const sprite = this.handCardSprites[index];
                    if (sprite) {
                        this.tweens.add({
                            targets: sprite,
                            x: -100,
                            rotation: -Math.PI / 2,
                            alpha: 0,
                            duration: 300
                        });
                    }
                });
                
                // Remove cards and draw new ones
                setTimeout(() => {
                    cardsToDiscard.sort((a, b) => b - a);
                    cardsToDiscard.forEach(index => {
                        this.playerHand.splice(index, 1);
                    });
                    
                    this.selectedCards.clear();
                    this.hasDiscardedThisRound = true;
                    
                    // Draw new cards
                    this.drawPlayerCards(discardCount);
                    this.renderHand();
                    this.updateUI();
                    
                    this.showMessage(`Discarded ${discardCount} cards`);
                }, 400);
            }

            discardRemainingHand() {
                this.playerHand.forEach(card => {
                    this.playerDiscardPile.push({
                        name: card.name,
                        cost: card.cost,
                        rarity: card.rarity,
                        position: card.position
                    });
                });
                this.playerHand = [];
            }

            endRound(playerPower) {
                // Calculate enemy power
                let enemyPower = 0;
                this.fieldCards.enemy.forEach(card => {
                    enemyPower += card.cost + card.rarity;
                });
                
                // Calculate yard gains
                const playerGain = Math.max(0, Math.floor((playerPower - enemyPower) / 2));
                const enemyGain = Math.max(0, Math.floor((enemyPower - playerPower) / 2));
                
                this.playerYards = Math.min(100, this.playerYards + playerGain);
                this.enemyYards = Math.min(100, this.enemyYards + enemyGain);
                
                this.updateUI();
                this.showMessage(`You: ${playerPower} (+${playerGain}yd) | Enemy: ${enemyPower} (+${enemyGain}yd)`);
                
                // Check win conditions
                if (this.playerYards >= 100) {
                    this.time.delayedCall(2000, () => this.showMessage("ðŸ† TOUCHDOWN! YOU WIN!"));
                } else if (this.enemyYards >= 100) {
                    this.time.delayedCall(2000, () => this.showMessage("ðŸ’€ ENEMY SCORED! YOU LOSE!"));
                } else {
                    // Clear field and start new round
                    this.time.delayedCall(2500, () => {
                        this.clearField();
                        this.hasDiscardedThisRound = false;
                        this.round++;
                        this.startNewRound();
                    });
                }
            }

            clearField() {
                // Add field cards to discard piles
                this.fieldCards.player.forEach(card => {
                    this.playerDiscardPile.push({
                        name: card.name,
                        cost: card.cost,
                        rarity: card.rarity,
                        position: card.position
                    });
                });
                
                this.fieldCards.enemy.forEach(card => {
                    this.enemyDiscardPile.push({
                        name: card.name,
                        cost: card.cost,
                        rarity: card.rarity,
                        position: card.position
                    });
                });
                
                // Animate field cards disappearing
                [...this.fieldCardSprites.player, ...this.fieldCardSprites.enemy].forEach((sprite, i) => {
                    this.tweens.add({
                        targets: sprite,
                        alpha: 0,
                        scaleX: 0,
                        scaleY: 0,
                        duration: 300,
                        delay: i * 50,
                        onComplete: () => sprite.destroy()
                    });
                });
                
                // Clear arrays
                this.fieldCards = { player: [], enemy: [] };
                this.fieldCardSprites = { player: [], enemy: [] };
            }

            shuffleDiscardIntoDeck() {
                this.playerDrawPile = Phaser.Utils.Array.Shuffle([...this.playerDiscardPile]);
                this.playerDiscardPile = [];
                this.showMessage("ðŸ”„ Deck reshuffled!");
            }

            shuffleEnemyDiscardIntoDeck() {
                this.enemyDrawPile = Phaser.Utils.Array.Shuffle([...this.enemyDiscardPile]);
                this.enemyDiscardPile = [];
                this.showMessage("ðŸ”„ Enemy deck reshuffled!");
            }

            showMessage(text) {
                const { width, height } = this.scale;
                
                // Create message container
                const messageContainer = this.add.container(width / 2, height / 2);
                
                // Background
                const bg = this.add.graphics();
                bg.fillStyle(0x000000, 0.9);
                bg.fillRoundedRect(-150, -30, 300, 60, 10);
                bg.lineStyle(2, 0xffffff);
                bg.strokeRoundedRect(-150, -30, 300, 60, 10);
                
                // Text
                const messageText = this.add.text(0, 0, text, {
                    fontSize: '16px',
                    color: '#fff',
                    fontStyle: 'bold',
                    align: 'center',
                    wordWrap: { width: 280 }
                }).setOrigin(0.5, 0.5);
                
                messageContainer.add([bg, messageText]);
                messageContainer.setDepth(1000);
                
                // Animate in
                messageContainer.setScale(0);
                this.tweens.add({
                    targets: messageContainer,
                    scaleX: 1,
                    scaleY: 1,
                    duration: 300,
                    ease: 'Back.easeOut'
                });
                
                // Fade out and destroy
                this.time.delayedCall(2500, () => {
                    this.tweens.add({
                        targets: messageContainer,
                        alpha: 0,
                        y: height / 2 - 50,
                        duration: 500,
                        onComplete: () => messageContainer.destroy()
                    });
                });
            }

            updateUI() {
                this.enemyYardsText.setText(`Enemy Yards ${this.enemyYards}/100`);
                this.playerYardsText.setText(`Your Yards ${this.playerYards}/100`);
                this.cardsRemainingText.setText(`ðŸ‚¡ ${this.playerDrawPile.length}/${this.playerDeck.length}`);
                this.enemyDeckText.setText(`Enemy: ðŸ‚¡ ${this.enemyDrawPile.length}/${this.enemyDeck.length}`);
                
                // Update discard button appearance
                const discardBg = this.discardBtn.list[0];
                if (this.hasDiscardedThisRound) {
                    discardBg.setAlpha(0.5);
                    discardBg.disableInteractive();
                } else {
                    discardBg.setAlpha(1);
                    discardBg.setInteractive({ useHandCursor: true });
                }
            }
        }

        // Game configuration
        const gameConfig = {
            type: Phaser.AUTO,
            parent: 'game-container',
            width: 400,
            height: 700,
            backgroundColor: '#f8f9fa',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            scene: FootballCardGame
        };

        // Handle mobile viewport
        function updateViewport() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            
            // Update game size for mobile
            if (window.innerWidth <= 768) {
                gameConfig.width = Math.min(window.innerWidth, 420);
                gameConfig.height = window.innerHeight;
            }
        }

        updateViewport();
        window.addEventListener('resize', updateViewport);
        window.addEventListener('orientationchange', () => {
            setTimeout(updateViewport, 100);
        });

        // Create game
        let game;
        
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('DOM loaded, creating game...');
                game = new Phaser.Game(gameConfig);
            });
        } else {
            console.log('Creating game immediately...');
            game = new Phaser.Game(gameConfig);
        }

        // Debug - check if Phaser loaded
        console.log('Phaser version:', Phaser.VERSION);
    </script>
</body>
</html>